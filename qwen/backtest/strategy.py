"""Strategy base class for backtesting."""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Optional

import pandas as pd


@dataclass
class Signal:
    """Trading signal generated by a strategy."""

    symbol: str
    action: str  # 'buy', 'sell', 'hold'
    quantity: Optional[float] = None  # None means use position sizing
    price: Optional[float] = None  # None means market order
    reason: str = ""
    metadata: Optional[dict[str, Any]] = None

    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


class Strategy(ABC):
    """
    Abstract base class for trading strategies.

    Implement on_bar() to define your trading logic.
    """

    def __init__(self, name: str = None):
        """
        Initialize strategy.

        Args:
            name: Strategy name (defaults to class name)
        """
        self.name = name or self.__class__.__name__
        self._portfolio = None
        self._broker = None
        self._current_bar = None
        self._history = None

    def set_context(self, portfolio, broker, history: pd.DataFrame):
        """Set backtesting context (called by engine)."""
        self._portfolio = portfolio
        self._broker = broker
        self._history = history

    @property
    def portfolio(self):
        """Access to portfolio for position information."""
        return self._portfolio

    @property
    def broker(self):
        """Access to broker for order submission."""
        return self._broker

    @property
    def history(self) -> pd.DataFrame:
        """Historical price data up to current bar."""
        return self._history

    @abstractmethod
    def on_bar(self, bar: pd.Series) -> list[Signal]:
        """
        Called for each bar of data.

        Override this method to implement your trading logic.

        Args:
            bar: Current price bar with OHLCV data
                 Index contains: Open, High, Low, Close, Volume

        Returns:
            List of trading signals
        """
        pass

    def on_start(self):
        """Called before backtest starts. Override for initialization."""
        pass

    def on_end(self):
        """Called after backtest ends. Override for cleanup."""
        pass

    def on_order_filled(self, order):
        """Called when an order is filled. Override for tracking."""
        pass

    # Helper methods for common operations

    def get_position(self, symbol: str) -> float:
        """Get current position quantity for a symbol."""
        if self._portfolio is None:
            return 0
        return self._portfolio.get_quantity(symbol)

    def has_position(self, symbol: str) -> bool:
        """Check if we have an open position."""
        return self.get_position(symbol) != 0

    def is_long(self, symbol: str) -> bool:
        """Check if we have a long position."""
        return self.get_position(symbol) > 0

    def is_short(self, symbol: str) -> bool:
        """Check if we have a short position."""
        return self.get_position(symbol) < 0

    def buy(self, symbol: str, quantity: float = None, reason: str = "") -> Signal:
        """Create a buy signal."""
        return Signal(symbol=symbol, action="buy", quantity=quantity, reason=reason)

    def sell(self, symbol: str, quantity: float = None, reason: str = "") -> Signal:
        """Create a sell signal."""
        return Signal(symbol=symbol, action="sell", quantity=quantity, reason=reason)

    def hold(self, symbol: str = "", reason: str = "") -> Signal:
        """Create a hold signal (no action)."""
        return Signal(symbol=symbol, action="hold", reason=reason)

    def close_position(self, symbol: str, reason: str = "") -> Signal:
        """Create a signal to close existing position."""
        qty = self.get_position(symbol)
        if qty > 0:
            return Signal(symbol=symbol, action="sell", quantity=qty, reason=reason)
        elif qty < 0:
            return Signal(symbol=symbol, action="buy", quantity=abs(qty), reason=reason)
        return self.hold(symbol, "No position to close")


class SimpleMovingAverageCrossover(Strategy):
    """
    Example strategy: Simple Moving Average Crossover.

    Buys when short MA crosses above long MA.
    Sells when short MA crosses below long MA.
    """

    def __init__(self, symbol: str, short_window: int = 20, long_window: int = 50):
        super().__init__(f"SMA_{short_window}_{long_window}")
        self.symbol = symbol
        self.short_window = short_window
        self.long_window = long_window

    def on_bar(self, bar: pd.Series) -> list[Signal]:
        if len(self._history) < self.long_window:
            return []

        closes = self._history["Close"]
        short_ma = closes.rolling(self.short_window).mean().iloc[-1]
        long_ma = closes.rolling(self.long_window).mean().iloc[-1]

        prev_closes = closes.iloc[:-1]
        if len(prev_closes) < self.long_window:
            return []

        prev_short_ma = prev_closes.rolling(self.short_window).mean().iloc[-1]
        prev_long_ma = prev_closes.rolling(self.long_window).mean().iloc[-1]

        signals = []

        # Golden cross (short crosses above long)
        if prev_short_ma <= prev_long_ma and short_ma > long_ma:
            if not self.is_long(self.symbol):
                signals.append(self.buy(self.symbol, reason="Golden cross"))

        # Death cross (short crosses below long)
        elif prev_short_ma >= prev_long_ma and short_ma < long_ma:
            if self.is_long(self.symbol):
                signals.append(self.close_position(self.symbol, reason="Death cross"))

        return signals
